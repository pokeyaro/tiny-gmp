# Go 调度器设计：`Runnext` 快速通道与被动补充策略

**标语:** _唯一的 VIP 座位，永远排在最前面。_

在谈到 Go 的调度器时，大多数人会想到每个处理器（P）的**本地运行队列**（`runq`）。但还有一个特殊的**快速通道**——一个单槽位的 VIP 通道，叫 **`runnext`**。

---

## 什么是 `runnext`？

所有可运行的 goroutine 像顾客一样在本地队列中排队。`runnext` 是一个**专属的单槽位**，位于队列最前端：

- **容量:** 每个 P 只能有 1 个 goroutine
- **优先级:** 总是比 `runq` 中的任务先执行
- **目的:** 让新创建的 goroutine 立即运行，减少调度延迟

**类比:** `runnext` 就像机场安检的快速通道——可以直接跳过长队。

---

## `runqget` 如何工作

```zig
pub fn runqget(self: *Self, p: *P) WorkItem {
    // 快速通道: 先检查 runnext
    if (p.getRunnext()) |g| {
        p.clearRunnext(); // 不主动补充
        return .{ .g = g, .src = .Runnext };
    }

    // 慢速通道: 从普通 runq 获取
    const g = p.runq.dequeue();
    return .{ .g = g, .src = .Runq };
}
```

流程：

1. 检查 `runnext`——如果有，就取它。
2. 如果为空，则从 `runq` 中取。

---

## 被动补充策略

Go 使用**被动补充**策略：

- 一旦 `runnext` 被取走，它会**保持为空**，直到有新的 goroutine 被显式放入其中。
- 不会自动从 `runq` 提升任务到 `runnext`。

### 为什么不用主动补充？

另一种方法是：当 `runnext` 为空时，**立即**将 `runq` 的第一个任务移动进去。

**缺点:**

- 增加复杂性，增加 bug 风险
- 每次出队都多做一步操作
- 可能破坏公平性——某个 goroutine 可能反复插队
- 偏离 Go 的真实实现

---

## 被动策略的优势

1. **简单可靠**——更少的逻辑，更少的错误
2. **保留本意**——`runnext` 仅作为新 goroutine 的快速通道
3. **公平性**——已有的 `runq` 排序不被打乱
4. **自然补充**——实际场景中，新建 goroutine 频繁，`runnext` 很少长时间为空
5. **与 Go 一致**——符合 `proc.go` 中的真实调度器逻辑

---

## 策略对比

| 策略     | 优点                             | 缺点                     |
| -------- | -------------------------------- | ------------------------ |
| 被动补充 | 简单、公平、低开销、符合 Go 实现 | 可能短暂为空             |
| 主动补充 | 始终保持快速通道有任务           | 复杂、降低公平性、开销大 |

---

## 现实类比

咖啡店有一张 VIP 桌：

- **被动:** 只给新到的 VIP 客人，如果没人符合条件，就空着。
- **主动:** 桌子一空，就从普通队列里拉人来坐——打乱顺序，增加额外操作。

Go 选择**被动补充**，因为它简洁、公平，并且能让 VIP 座位留给真正的 VIP。

---

**参考:** Go 源码 — `runtime/proc.go`, `runqget`

作者: Pokeya 日期: 2025-08-06
