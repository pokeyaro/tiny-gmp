# Go 调度器设计：Work-Stealing —— 让闲置的 P 发挥主观能动性

## 背景

在多处理器（P）调度中，如果某个 P 的本地任务耗尽，它就会陷入空闲状态。这时，系统整体的吞吐量可能下降：一些 P 忙得不可开交，另一些却在发呆。

**Work-stealing** 的哲学是：

> “不要等活上门，自己去找活干。”

这样，空闲的 P 就能主动从其他忙碌的 P 那里搬走一部分任务，平衡负载。

## 核心理念

- **主动性**：Idle P 不依赖全局信号，而是周期性地去扫描潜在的“受害者”。
- **有限性**：不是无限乱扫，而是有**预算**和**规则**，防止无意义的资源消耗。
- **非暴力偷取**：不会一次掏空别人，只拿走一半，保留对方继续运行的能力。
- **跳过“VIP”**：高优先级的临时任务（如 `runnext`）不参与偷取，减少干扰。

## Victim 扫描的哲学

1. **随机化起点**

   - 固定顺序会让某些 P 成为 “常年受害者”，不公平。
   - 随机起点可以让“谁被偷”更均匀。

2. **环形扫描（Ring Scan）**

   - 从起点开始按 P ID 环形遍历所有 P。
   - 自己（thief）会跳过，避免自偷。

3. **多轮预算（steal budget）**

   - 为了避免无限空转，我们设定扫描预算：`stealTries × nproc`。
   - 每次扫描一个 victim 就消耗一次预算。
   - 有了多轮扫描的好处是，即使第一轮所有 victim 都是空的，也能在后续轮次赶上刚刚入队的新任务。

4. **不碰 runnext**

   - **与 Go runtime 的差异**：故意不偷 victim 的 `runnext`，简化实现逻辑。
   - `runnext` 的任务通常是刚创建的、优先级高的 G，让 victim 自己先处理。

## 偷多少才合适？

- **一半（Half-Batch Steal）：**

  - 理论偷取数量 = `victim.runq.size / 2`（下取整）。
  - 足够让空闲 P “吃饱”，减少频繁偷取的开销。
  - 保证 victim 还能继续工作，不被掏空。

- **容量上限：**
  - 不超过 thief 本地队列的剩余容量。
  - 防止“搬回家放不下”的情况。

## 为什么这很重要

- **平衡吞吐量：** 让系统里所有处理器都有事做，减少闲置。
- **降低延迟：** 减少 “某个任务被长时间堵在忙碌的 P 上” 的概率。
- **提升体验：** 任务更快被完成，资源利用率更高。

---

作者：Pokeya 日期：2025-08-15
